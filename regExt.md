# 正则表达式小结

两个月前接触的正则表达式，当时觉得功能强大，能在终端下自动化很多工作

前几天发现原来各个程序语言都有集成这个功能，用来处理复杂的字符串，现在才知道，真是too young too simple。

现在就总结一下shell下的正则和js下的正则。
目前js下的正则能正确匹配汉字，但是似乎不能匹配大于\uFFFF的字符

## js

#### 数量匹配,默认是贪婪匹配，加上？后，表示为惰性匹配

+ + 匹配（1 ~ ∞）个前面的正则
+ ? 匹配（0～1）个前面的正则
+ * 匹配任意个前面的正则
+ {n, m}匹配（n～m）个前面的正则

#### 字符匹配

+ . 匹配任意字符,不包括\n，\r
+ \d 数字
+ \D 非数字
+ \w a-z,A-Z,下划线
+ \W 与\w取反
+ \s 空字符( space,\t,\r,\n )
+ \S 非空字符
+ \b 单词边界
+ \B 非单词边界

#### 位置匹配

+ ^ 开头
+ $ 结尾
+ (?=) 所在缝隙右侧等于
+ (?!) 所在缝隙右侧不等于

#### 注意点

string.match()函数，如果在正则表达式加上g属性，则可以匹配全文所有符合的字符串，返回一个数组
regext.exec()则无法实现这个功能

string.split(regext)函数可以把字符串利用正则表示的字符分隔成数组返回

string.search(), 类似于string.IndexOf()方法, 返回第一个符合的字符串序号

string.replace(), 很实用，可以使用$1, $2等后向引用

#### 标识符

i:忽略大小写
m:使匹配时的$^位置匹配符作用于每一行，不加时，是作用于整个字符串的头尾
g:全局




