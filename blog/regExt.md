# 正则表达式小结

两个月前接触的正则表达式，当时觉得功能强大，能在终端下自动化很多工作

前几天发现原来各个程序语言都有集成这个功能，用来处理复杂的字符串，现在才知道，真是too young too simple。

现在就总结一下shell下的正则和js下的正则。
目前js下的正则能正确匹配汉字，但是似乎不能匹配大于\uFFFF的字符

## js

#### 数量匹配,默认是贪婪匹配，加上？后，表示为惰性匹配

+ + 匹配（1 ~ ∞）个前面的正则
+ ? 匹配（0～1）个前面的正则
+ * 匹配任意个前面的正则
+ {n, m}匹配（n～m）个前面的正则

#### 字符匹配

+ . 匹配任意字符,不包括\n，\r
+ \d 数字
+ \D 非数字
+ \w a-z,A-Z,下划线
+ \W 与\w取反
+ \s 空字符( space,\t,\r,\n )
+ \S 非空字符
+ \b 单词边界
+ \B 非单词边界

#### 位置匹配

+ ^ 开头
+ $ 结尾
+ (?=) 所在缝隙右侧等于
+ (?!) 所在缝隙右侧不等于

#### 注意点

string.match()函数，如果在正则表达式加上g属性，则可以匹配全文所有符合的字符串，返回一个数组
regext.exec()则无法实现这个功能

string.split(regext)函数可以把字符串利用正则表示的字符分隔成数组返回

string.search(), 类似于string.IndexOf()方法, 返回第一个符合的字符串序号

string.replace(), 很实用，可以使用$1, $2等后向引用

#### 标识符

i:忽略大小写
m:使匹配时的$^位置匹配符作用于每一行，不加时，是作用于整个字符串的头尾
g:全局

## shell

### grep

-B n 显示匹配行的前n行
-A n 显示匹配行的后n行
-o 只显示匹配的内容
-v 反向匹配
-n 显示行号

--include=xx 递归时，只匹配和xx通配符符合的文件名
--exclude=xx　与include相反




### sed

`sed '/0109/d' file`
删除含有0109的行

`sed '\:reg: s;xx;xx;' file`
对含有reg的行进行替换操作，\后面的为定界符，默认为/，
`sed '\:reg:!s;xx;xx;' file`
对不喊又reg操作的行进行替换操作

`sed '\dfunctiond,/}/ s;xx;xx;' file`
d为定界符，对从'function'到'}'的行进行操作，并且若有多个目标符合条件，会同时作用

-n　加入此选项之后，只有加了p操作的行才会被显示